{"version":3,"file":"background.9c52a882d5951b7b6e66.hot-update.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7PA","sources":["webpack://chrome-extension-boilerplate-react/./src/pages/Background/index.ts","webpack://chrome-extension-boilerplate-react/webpack/runtime/getFullHash"],"sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nlet openedTabId = null;\r\nlet SingleFlag = false;\r\nlet MultipleFlag = false;\r\nlet PlaylistFlag = false;\r\nlet ChannelFlag = false;\r\nconst OPENAI_API_KEY = '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';\r\nconst STORAGE_KEYS = {\r\n    MAIN: 'mainMultipleLinks',\r\n    RANGE: 'rangeMultipleLinks',\r\n    ACTION: 'multipleActionLinks',\r\n    PROCESSED: 'processedLinks',\r\n    PLAYLIST_PROCESSED: 'playlistProcessedLinks',\r\n    PLAYLIST_RANGE: 'playlistRangeLinks',\r\n    PLAYLIST_ACTIONS: 'playlistActionLinks',\r\n    CHANNEL: 'channellinkLists',\r\n};\r\nconst delay = (ms) => new Promise((res) => setTimeout(res, ms));\r\nlet multipleQueue = [];\r\nlet multipleActions = { subscribe: [], like: [], comment: [] };\r\nlet multipleIsRange = false;\r\nlet playlistQueue = [];\r\nlet playlistActions = { subscribe: [], like: [], comment: [] };\r\nlet playlistIsRange = false;\r\nlet channelQueue = [];\r\nfunction openTab(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        console.log(url);\r\n        const check = url;\r\n        yield chrome.storage.local.set({ check });\r\n        const tab = yield new Promise((res) => chrome.tabs.create({ url, active: true }, res));\r\n        openedTabId = tab.id;\r\n        yield chrome.storage.local.set({ singleVideoTabId: openedTabId });\r\n        yield delay(2000);\r\n        return openedTabId;\r\n    });\r\n}\r\nfunction sendToTab(action) {\r\n    if (openedTabId != null) {\r\n        chrome.tabs.sendMessage(openedTabId, { action });\r\n    }\r\n}\r\nchrome.runtime.onMessage.addListener((message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const { action, link, nextAction, videoTitle } = message;\r\n    switch (action) {\r\n        case 'Subscribe':\r\n        case 'Like':\r\n        case 'Comment':\r\n        case 'SLC':\r\n            SingleFlag = true;\r\n            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\r\n                var _a;\r\n                const t = (_a = tabs[0]) === null || _a === void 0 ? void 0 : _a.id;\r\n                if (t != null)\r\n                    chrome.tabs.sendMessage(t, {\r\n                        action: action === 'SLC'\r\n                            ? 'OpenFirstVideo&SLC'\r\n                            : `OpenFirstVideo&${action}`,\r\n                    });\r\n            });\r\n            break;\r\n        case 'StartAutomationMultiple':\r\n            MultipleFlag = true;\r\n            if (openedTabId)\r\n                chrome.tabs.remove(openedTabId);\r\n            {\r\n                const stored = yield chrome.storage.local.get([\r\n                    STORAGE_KEYS.MAIN,\r\n                    STORAGE_KEYS.RANGE,\r\n                    STORAGE_KEYS.ACTION,\r\n                ]);\r\n                const mainQ = stored[STORAGE_KEYS.MAIN] || [];\r\n                const rangeQ = stored[STORAGE_KEYS.RANGE] || [];\r\n                const acts = stored[STORAGE_KEYS.ACTION] || {\r\n                    subscribe: [],\r\n                    like: [],\r\n                    comment: [],\r\n                };\r\n                multipleIsRange = rangeQ.length > 0;\r\n                multipleQueue = multipleIsRange ? rangeQ : mainQ;\r\n                multipleActions = acts;\r\n            }\r\n            initMultipleProcessing();\r\n            break;\r\n        case 'StartAutomationPlaylist':\r\n            PlaylistFlag = true;\r\n            if (openedTabId)\r\n                chrome.tabs.remove(openedTabId);\r\n            {\r\n                const stored = yield chrome.storage.local.get([\r\n                    STORAGE_KEYS.PLAYLIST_PROCESSED,\r\n                    STORAGE_KEYS.PLAYLIST_RANGE,\r\n                    STORAGE_KEYS.PLAYLIST_ACTIONS,\r\n                ]);\r\n                const procQ = stored[STORAGE_KEYS.PLAYLIST_PROCESSED] || [];\r\n                const rangeQ = stored[STORAGE_KEYS.PLAYLIST_RANGE] || [];\r\n                const acts = stored[STORAGE_KEYS.PLAYLIST_ACTIONS] || {\r\n                    subscribe: [],\r\n                    like: [],\r\n                    comment: [],\r\n                };\r\n                playlistIsRange = rangeQ.length > 0;\r\n                playlistQueue = playlistIsRange ? rangeQ : procQ;\r\n                playlistActions = acts;\r\n            }\r\n            initPlaylistProcessing();\r\n            break;\r\n        case 'PlayChannelVideos':\r\n            ChannelFlag = true;\r\n            if (openedTabId)\r\n                chrome.tabs.remove(openedTabId);\r\n            const stored = yield chrome.storage.local.get([STORAGE_KEYS.CHANNEL]);\r\n            channelQueue = stored[STORAGE_KEYS.CHANNEL] || [];\r\n            initChannelProcessing();\r\n            break;\r\n        case 'SearchChannel':\r\n            ChannelFlag = true;\r\n            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\r\n                var _a;\r\n                const t = (_a = tabs[0]) === null || _a === void 0 ? void 0 : _a.id;\r\n                if (t != null)\r\n                    chrome.tabs.sendMessage(t, { action: 'FindChannel' });\r\n            });\r\n            break;\r\n        case 'openSingleVideoTab':\r\n            if (link && nextAction) {\r\n                const check = link;\r\n                yield chrome.storage.local.set({ check });\r\n                const tab = yield new Promise((res) => chrome.tabs.create({ url: link, active: true }, res));\r\n                openedTabId = tab.id;\r\n                chrome.storage.local.set({ singleVideoTabId: openedTabId });\r\n                chrome.tabs.onUpdated.addListener(function listener(id, info) {\r\n                    if (id === openedTabId && info.status === 'complete') {\r\n                        sendToTab(nextAction);\r\n                        chrome.tabs.onUpdated.removeListener(listener);\r\n                    }\r\n                });\r\n            }\r\n            break;\r\n        case 'actionDone':\r\n            if (SingleFlag) {\r\n                sendToTab('showCompletedModal');\r\n            }\r\n            else if (MultipleFlag) {\r\n                const isLast = multipleQueue.length === 1;\r\n                const current = multipleQueue.shift();\r\n                if (current) {\r\n                    const mem = yield chrome.storage.local.get(STORAGE_KEYS.PROCESSED);\r\n                    const proc = mem[STORAGE_KEYS.PROCESSED] || [];\r\n                    const idx = proc.findIndex((i) => i.id === current.id);\r\n                    if (idx >= 0)\r\n                        proc[idx] = Object.assign({}, current);\r\n                    else\r\n                        proc.push(Object.assign({}, current));\r\n                    yield chrome.storage.local.set({ [STORAGE_KEYS.PROCESSED]: proc });\r\n                    const key = multipleIsRange ? STORAGE_KEYS.RANGE : STORAGE_KEYS.MAIN;\r\n                    yield chrome.storage.local.set({ [key]: multipleQueue });\r\n                }\r\n                if (isLast) {\r\n                    sendToTab('showCompletedModal');\r\n                }\r\n                else {\r\n                    chrome.tabs.remove(openedTabId);\r\n                    initMultipleProcessing();\r\n                }\r\n            }\r\n            else if (PlaylistFlag) {\r\n                const isLast = playlistQueue.length === 1;\r\n                const current = playlistQueue.shift();\r\n                if (current) {\r\n                    const mem = yield chrome.storage.local.get(STORAGE_KEYS.PLAYLIST_PROCESSED);\r\n                    const proc = mem[STORAGE_KEYS.PLAYLIST_PROCESSED] || [];\r\n                    const idx = proc.findIndex((i) => i.id === current.id);\r\n                    if (idx >= 0)\r\n                        proc[idx] = Object.assign({}, current);\r\n                    else\r\n                        proc.push(Object.assign({}, current));\r\n                    yield chrome.storage.local.set({\r\n                        [STORAGE_KEYS.PLAYLIST_PROCESSED]: proc,\r\n                    });\r\n                    const key = playlistIsRange\r\n                        ? STORAGE_KEYS.PLAYLIST_RANGE\r\n                        : STORAGE_KEYS.PLAYLIST_PROCESSED;\r\n                    yield chrome.storage.local.set({ [key]: playlistQueue });\r\n                }\r\n                if (isLast) {\r\n                    sendToTab('showCompletedModal');\r\n                }\r\n                else {\r\n                    chrome.tabs.remove(openedTabId);\r\n                    initPlaylistProcessing();\r\n                }\r\n            }\r\n            else if (ChannelFlag) {\r\n                const isLast = channelQueue.length === 1;\r\n                const current = channelQueue.shift();\r\n                if (current) {\r\n                    const mem = yield chrome.storage.local.get(STORAGE_KEYS.PROCESSED);\r\n                    const proc = mem[STORAGE_KEYS.PROCESSED] || [];\r\n                    const idx = proc.findIndex((i) => i.id === current.id);\r\n                    if (idx >= 0)\r\n                        proc[idx] = Object.assign({}, current);\r\n                    else\r\n                        proc.push(Object.assign({}, current));\r\n                    yield chrome.storage.local.set({ [STORAGE_KEYS.PROCESSED]: proc });\r\n                    yield chrome.storage.local.set({\r\n                        [STORAGE_KEYS.CHANNEL]: channelQueue,\r\n                    });\r\n                }\r\n                if (isLast) {\r\n                    sendToTab('showCompletedModal');\r\n                }\r\n                else {\r\n                    chrome.tabs.remove(openedTabId);\r\n                    initChannelProcessing();\r\n                }\r\n            }\r\n            break;\r\n        case 'completedModalClosed':\r\n            if (openedTabId)\r\n                chrome.tabs.remove(openedTabId);\r\n            openedTabId = null;\r\n            SingleFlag = false;\r\n            MultipleFlag = false;\r\n            PlaylistFlag = false;\r\n            ChannelFlag = false;\r\n            break;\r\n        case 'generatecomment':\r\n            if (videoTitle) {\r\n                const comment = yield generateAIComment(videoTitle);\r\n                if (comment) {\r\n                    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\r\n                        var _a;\r\n                        const t = (_a = tabs[0]) === null || _a === void 0 ? void 0 : _a.id;\r\n                        if (t != null)\r\n                            chrome.tabs.sendMessage(t, {\r\n                                action: 'postGeneratedComment',\r\n                                comment,\r\n                            });\r\n                    });\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}));\r\n","__webpack_require__.h = () => (\"18f7fbacb5308f0d59c7\")"],"names":[],"sourceRoot":""}